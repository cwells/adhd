#!/bin/env python

"Much of this code was intentional."

import contextlib
import os
import subprocess
import sys
import time
import webbrowser
from pathlib import Path
from typing import Any

from lib.boot import missing_modules

required_modules: dict[str, str] = {
    "box": "python-box",
    "click": "click",
    "rich": "rich",
    "toposort": "toposort",
    "yaml": "PyYAML",
    "yarl": "yarl",
}

if missing := missing_modules(required_modules):
    print("You need to install this program's dependencies, e.g. `python -m pip install -r requirements.txt\n")
    print(f"Missing modules: {', '.join(missing)}\n")
    sys.exit(1)

import click
import rich.console
import rich.prompt
import yaml
from lib.jobs import get_job, get_jobs
from lib.loader import get_loader
from lib.shell import shell
from lib.util import (
    ConfigBox,
    EnvParamType,
    PluginParamType,
    ProjectParamType,
    Style,
    _exit,
    check_project,
    console,
    get_local_env,
    print_job_help,
)
from plugins import BasePlugin, list_plugins, load_plugins

# ==============================================================================


def read_project_config(project: str) -> dict[str, Any]:
    with open(project) as config_file:
        return ConfigBox(yaml.load(config_file, Loader=get_loader()))


# ==============================================================================


@click.command()
@click.option("--home/--no-home", default=True, help="Change to project HOME directory")
@click.option("-e", "--env", type=EnvParamType(), multiple=True, help="Define env var(s) from CLI")
@click.option("-p", "--plugin", type=PluginParamType(), multiple=True, help="Manage plugins using plugin:[on|off]")
@click.option("--help-jobs", is_flag=True, default=False, help="Display available jobs and help text")
@click.option("--help-plugins", is_flag=True, default=False, help="Display available plugins and help text")
@click.option("--explain", is_flag=True, default=False, help="Display help text from job and its dependencies")
@click.option("-v", "--verbose", is_flag=True, default=False, help="Send stdout of all jobs to console")
@click.option("--debug", is_flag=True, default=False, help="Generate extremely verbose output")
@click.option("-f", "--force", is_flag=True, default=False, help="Bypass skip checks")
@click.option("--fix-perms", is_flag=True, default=False, help="Fix file permissions")
@click.argument("project", type=ProjectParamType())
@click.argument("command", nargs=-1)
def main(
    home: bool,
    env: list[tuple[str, str]],
    plugin: list[tuple[str, bool]],
    project: str,
    command: tuple[str] | list[str],
    help_jobs: bool,
    help_plugins: bool,
    explain: bool,
    verbose: bool,
    debug: bool,
    force: bool,
    fix_perms: bool,
) -> None:
    options_env: dict[str, str] = ConfigBox(env)
    process_env: dict[str, str] = ConfigBox()
    project_config: ConfigBox = ConfigBox()
    plugins_enabled: dict[str, bool] = dict(plugin)
    plugins: dict[str, BasePlugin]
    job: ConfigBox
    task: str
    style: Style | str
    returncode: int = 0

    verbose = True if debug else verbose

    if not check_project(project, fix_perms=fix_perms):
        sys.exit(1)

    # read configuration
    try:
        project_config.update(read_project_config(project))
        process_env.update(get_local_env(project_config, options_env))
    except Exception as e:
        console.print(f"{Style.ERROR}loading configuration {project}:\n")
        _exit(e, verbose=verbose, debug=debug)

    silent: bool = project_config.get("silent", False)

    # display list of possible jobs
    if help_jobs:
        jobs = {
            name: get_job(
                command,
                job,
                project_config["jobs"],
                process_env,
                informational=True,
            )
            for name, job in project_config["jobs"].items()
        }
        print_job_help(jobs)
        raise SystemExit

    if help_plugins:
        list_plugins()
        raise SystemExit

    if explain:
        console.print("\n[bold]The following jobs would be run, in this order:[/]\n")
        plugins = {}
    else:
        plugins = load_plugins(
            project_config=project_config,
            process_env=process_env,
            enabled=plugins_enabled,
            silent=silent,
            verbose=verbose,
            debug=debug,
        )

    #
    # main loop - get_jobs() returns topologically-sorted list of jobs
    #
    for job in get_jobs(
        command,
        project_config,
        process_env,
        plugins,
        silent=silent,
        verbose=verbose,
        debug=debug,
    ):
        if debug:
            console.print(job.to_dict())

        if explain:
            skip: bool = job.get("skip") and force is False
            style = (Style.RUN, Style.SKIP)[skip]
            text: str = job.get("help", "No description.")
            console.print(f"{style} [bold cyan]{job['name']}[/]: [cyan]{text}")
            if verbose:
                style = (Style.TASK_RUN, Style.TASK_SKIP)[skip]
                for task in job.get("tasks", []):
                    for idx, line in enumerate(task.split("\n")):
                        if _l := line.rstrip():
                            _style = style if idx == 0 else f"     [{('white', 'grey50')[skip]}]"
                            console.print(f"{_style}{_l}", highlight=False)
                console.print()
            continue

        capture: bool = job.get("capture", False)
        interactive: bool = job.get("interactive", False) or verbose
        silent = job.get("silent", False)
        workdir: Path = Path(job.get("workdir", ".")).expanduser().resolve()

        # go to workdir, if defined and not overridden by cli
        if home:
            try:
                if workdir.exists():
                    os.chdir(workdir)
            except Exception as e:
                console.print(f"{Style.ERROR}changing to directory {workdir}:\n")
                _exit(e, verbose=verbose, debug=debug)

        # skip / confirm
        if job.get("skip") and force is False:
            if not silent:
                console.print(f'{Style.SKIPPED}[bold blue]{job["name"]}[/]')
            continue
        elif confirm := job.get("confirm"):
            if not rich.prompt.Confirm.ask(confirm, default=False, console=console):
                if not rich.prompt.Confirm.ask(
                    "Would you like to continue?",
                    console=console,
                    choices=["continue", "abort"],
                    default="abort",
                ):
                    raise SystemExit("Aborted by user request.\n")
        else:
            if not silent:
                console.print(f"{Style.STARTING}[bold blue]{job['name']}[/]")

        # each job can be composed of multiple tasks
        for task in job["tasks"]:
            process: subprocess.CompletedProcess | None = None
            returncode = 0

            # don't use console.status unless capturing output
            ctx: contextlib.AbstractContextManager = (
                console.status(f"Running [yellow]{task}[/]")  # type: ignore
                if capture or not (interactive or silent)
                else contextlib.nullcontext()  # do-nothing context manager
            )
            with ctx:
                try:
                    process = shell(
                        command=task,
                        workdir=workdir,
                        env=job["env"],
                        capture=capture,
                        interactive=interactive and not capture,
                    )
                    returncode = process.returncode
                except Exception as e:
                    console.print(f"{Style.ERROR}loading executing {task}:\n")
                    _exit(e, verbose=verbose, debug=debug)
                else:
                    if not silent:
                        console.print(f"{Style.FINISHED}[white]task(s)[/]", highlight=False)
                        for idx, line in enumerate(task.split("\n")):
                            style = Style.TASK_RUN if idx == 0 else "     "
                            console.print(f"{style}[dark_goldenrod]{line}[/]", highlight=False)

            if returncode == 0:
                if tts := job.get("sleep", 0):
                    if verbose:
                        console.print(f"[bold]Sleeping for {tts} seconds.")
                    time.sleep(tts)
            else:
                console.print(f"{Style.ERROR}Error: {task} exited with non-zero status.")
                if process is not None and process.stderr:
                    console.print(f"{Style.ERROR}{process.stderr.decode('utf-8')}")

        # finally, open any uris specified in job config
        if uri := job.get("open"):
            if isinstance(uri, str):
                uri = [uri]
            for _u in uri:
                webbrowser.open_new_tab(_u)
                console.print(f"{Style.OPEN_FINISHED}[yellow]{_u}[/]", highlight=False)

        if not silent:
            console.print(f"{Style.FINISHED}[bold blue]{job['name']}[/]")

    if explain:
        console.print()
    elif not silent:
        console.print(f"{Style.FINISHED}Finished all jobs.")

    sys.exit(returncode)


# ==============================================================================

if __name__ == "__main__":
    main()  # type: ignore
